{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"meiga \ud83e\uddd9 \u00b6 What is meiga? \u00b6 meiga is a Python \u00b5framework that provides a simple, fully typed, monad-based result type ( Result[Value, Error] ). How could meiga help me? \u00b6 meiga provides a simple and clear way of handling errors in Python without using Exceptions . This package improves the Dev Experience as it allows to know all possible typed responses. With meiga your IDE will help you much more. Content \u00b6","title":"Overview"},{"location":"#meiga","text":"","title":"meiga \ud83e\uddd9"},{"location":"#what-is-meiga","text":"meiga is a Python \u00b5framework that provides a simple, fully typed, monad-based result type ( Result[Value, Error] ).","title":"What is meiga?"},{"location":"#how-could-meiga-help-me","text":"meiga provides a simple and clear way of handling errors in Python without using Exceptions . This package improves the Dev Experience as it allows to know all possible typed responses. With meiga your IDE will help you much more.","title":"How could meiga help me?"},{"location":"#content","text":"","title":"Content"},{"location":"changelog/","text":"Review the Github Releases","title":"Changelog"},{"location":"contributing/","text":"We'd love you to contribute to meiga \ud83e\udd73\ud83e\udd73\ud83e\udd73\ud83e\udd73\ud83e\udd73\ud83e\udd73\ufe0f! Questions, feature requests and bug reports are all welcome as discussions or issues . However, to report a security vulnerability, please see our security policy .","title":"Contributing to meiga"},{"location":"getting_started/","text":"This package provides a new type class, the Result[Type, Type] . This Result type allows to simplify a wide range of problems, like handling potential undefined values, or reduce complexity handling exceptions. Additionally, your code can be simplified following a semantic pipeline reducing the visual noise of checking data types, controlling runtime flow and reducing side effects. Note This package is based in another solutions from another modern languages as this Swift-based Result implementation. The best way to illustrate how meiga can help you, is with some examples. Basic Example \u00b6 Consider the following example of a function that tries to extract a string ( str ) for a given key from a dict . from meiga import Result , Error class NoSuchKey ( Error ): ... class TypeMismatch ( Error ): ... def string_from_key ( dictionary : dict , key : str ) -> Result [ str , Error ]: # (1) if key not in dictionary . keys (): return Failure ( NoSuchKey ()) # (2) value = dictionary [ key ] if not isinstance ( value , str ): return Failure ( TypeMismatch ()) # (3) return Success ( value ) # (4) Result with str for success value and Error for failure. Equivalent to use Result(failure=NoSuchKey()) . Equivalent to use Result(failure=TypeMismatch()) . Equivalent to use Result(success=value) . Returned Result type provides a robust wrapper around the functions and methods. Rather than throw an exception, it returns a Result that either contains the success str value for the given key, or a typed failure with a specific and detailed Error ( Result[str, Error] ). Note We can be more specific returning a type as Result[str, NoSuchKey | TypeMismatch] or before PEP 604 (Python 3.10) , Result[str, Union[NoSuchKey,TypeMismatch]] . With this type hints we know specifically all result options of our use case. Code comparison \u00b6 In the following examples we compare the same use case using and not using meiga to type the return value. With meiga \ud83e\uddd9 Without meiga \ud83d\ude14 from __future__ import annotations from meiga import Error , Failure , Result , Success class NoSuchKey ( Error ): ... class TypeMismatch ( Error ): ... def string_from_key ( dictionary : dict , key : str ) -> Result [ str , NoSuchKey | TypeMismatch ]: # \ud83d\ude0a (1) if key not in dictionary . keys (): return Failure ( NoSuchKey ()) value = dictionary [ key ] if not isinstance ( value , str ): return Failure ( TypeMismatch ()) return Success ( value ) dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } str_value = string_from_key ( dictionary = dictionary , key = \"key1\" ) . unwrap () # \ud83d\ude0a (2) This return value is defined with all possible values \ud83c\udf89. I'll get a Result (either Success or Failure) and I know possible errors \ud83c\udf89. class NoSuchKey ( Exception ): ... class TypeMismatch ( Exception ): ... def string_from_key ( dictionary : dict , key : str ) -> str : # \ud83e\udd72 (1) if key not in dictionary . keys (): raise NoSuchKey () value = dictionary [ key ] if not isinstance ( value , str ): raise TypeMismatch () return value dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } key = \"key1\" try : # \ud83e\udd72 (2) str_value = string_from_key ( dictionary = dictionary , key = key ) except NoSuchKey : print ( f \"Key { key } does not exist\" ) except TypeMismatch : print ( f \"Value of Key { key } is not a string\" ) This return value masks the behavior of the unhappy path (Exceptions). \ud83e\udd72 We need to inspect the code to determine what exception might be raised. Only checking the signature of string_from_key method it is imposible to determine which exception should be consider. Test comparison \u00b6 As we can check in the following examples, meiga simplifies our tests with some useful assertion methods. With meiga \ud83e\uddd9 Without meiga \ud83d\ude14 import pytest from tests.unit.doc.example_without_meiga import ( NoSuchKey , TypeMismatch , string_from_key , ) @pytest . mark . unit class TestExampleWithMeiga : dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } def should_success ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"key1\" ) result . assert_success ( value_is_instance_of = str ) def should_fail_when_key_does_not_exist ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"invalid_key\" ) result . assert_failure ( value_is_instance_of = NoSuchKey ) def should_fail_when_type_mismatch ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"key2\" ) result . assert_failure ( value_is_instance_of = TypeMismatch ) import pytest from tests.unit.doc.example_without_meiga import ( NoSuchKey , TypeMismatch , string_from_key , ) @pytest . mark . unit class TestExampleWithoutMeiga : dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } def should_return_a_str ( self ): value = string_from_key ( dictionary = self . dictionary , key = \"key1\" ) assert isinstance ( value , str ) def should_raises_non_such_key_exception ( self ): with pytest . raises ( NoSuchKey ): _ = string_from_key ( dictionary = self . dictionary , key = \"invalid_key\" ) def should_raises_type_mismatch_exception ( self ): with pytest . raises ( TypeMismatch ): value = string_from_key ( dictionary = self . dictionary , key = \"key2\" ) assert not isinstance ( value , str )","title":"Getting started"},{"location":"getting_started/#basic-example","text":"Consider the following example of a function that tries to extract a string ( str ) for a given key from a dict . from meiga import Result , Error class NoSuchKey ( Error ): ... class TypeMismatch ( Error ): ... def string_from_key ( dictionary : dict , key : str ) -> Result [ str , Error ]: # (1) if key not in dictionary . keys (): return Failure ( NoSuchKey ()) # (2) value = dictionary [ key ] if not isinstance ( value , str ): return Failure ( TypeMismatch ()) # (3) return Success ( value ) # (4) Result with str for success value and Error for failure. Equivalent to use Result(failure=NoSuchKey()) . Equivalent to use Result(failure=TypeMismatch()) . Equivalent to use Result(success=value) . Returned Result type provides a robust wrapper around the functions and methods. Rather than throw an exception, it returns a Result that either contains the success str value for the given key, or a typed failure with a specific and detailed Error ( Result[str, Error] ). Note We can be more specific returning a type as Result[str, NoSuchKey | TypeMismatch] or before PEP 604 (Python 3.10) , Result[str, Union[NoSuchKey,TypeMismatch]] . With this type hints we know specifically all result options of our use case.","title":"Basic Example"},{"location":"getting_started/#code-comparison","text":"In the following examples we compare the same use case using and not using meiga to type the return value. With meiga \ud83e\uddd9 Without meiga \ud83d\ude14 from __future__ import annotations from meiga import Error , Failure , Result , Success class NoSuchKey ( Error ): ... class TypeMismatch ( Error ): ... def string_from_key ( dictionary : dict , key : str ) -> Result [ str , NoSuchKey | TypeMismatch ]: # \ud83d\ude0a (1) if key not in dictionary . keys (): return Failure ( NoSuchKey ()) value = dictionary [ key ] if not isinstance ( value , str ): return Failure ( TypeMismatch ()) return Success ( value ) dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } str_value = string_from_key ( dictionary = dictionary , key = \"key1\" ) . unwrap () # \ud83d\ude0a (2) This return value is defined with all possible values \ud83c\udf89. I'll get a Result (either Success or Failure) and I know possible errors \ud83c\udf89. class NoSuchKey ( Exception ): ... class TypeMismatch ( Exception ): ... def string_from_key ( dictionary : dict , key : str ) -> str : # \ud83e\udd72 (1) if key not in dictionary . keys (): raise NoSuchKey () value = dictionary [ key ] if not isinstance ( value , str ): raise TypeMismatch () return value dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } key = \"key1\" try : # \ud83e\udd72 (2) str_value = string_from_key ( dictionary = dictionary , key = key ) except NoSuchKey : print ( f \"Key { key } does not exist\" ) except TypeMismatch : print ( f \"Value of Key { key } is not a string\" ) This return value masks the behavior of the unhappy path (Exceptions). \ud83e\udd72 We need to inspect the code to determine what exception might be raised. Only checking the signature of string_from_key method it is imposible to determine which exception should be consider.","title":"Code comparison"},{"location":"getting_started/#test-comparison","text":"As we can check in the following examples, meiga simplifies our tests with some useful assertion methods. With meiga \ud83e\uddd9 Without meiga \ud83d\ude14 import pytest from tests.unit.doc.example_without_meiga import ( NoSuchKey , TypeMismatch , string_from_key , ) @pytest . mark . unit class TestExampleWithMeiga : dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } def should_success ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"key1\" ) result . assert_success ( value_is_instance_of = str ) def should_fail_when_key_does_not_exist ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"invalid_key\" ) result . assert_failure ( value_is_instance_of = NoSuchKey ) def should_fail_when_type_mismatch ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"key2\" ) result . assert_failure ( value_is_instance_of = TypeMismatch ) import pytest from tests.unit.doc.example_without_meiga import ( NoSuchKey , TypeMismatch , string_from_key , ) @pytest . mark . unit class TestExampleWithoutMeiga : dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } def should_return_a_str ( self ): value = string_from_key ( dictionary = self . dictionary , key = \"key1\" ) assert isinstance ( value , str ) def should_raises_non_such_key_exception ( self ): with pytest . raises ( NoSuchKey ): _ = string_from_key ( dictionary = self . dictionary , key = \"invalid_key\" ) def should_raises_type_mismatch_exception ( self ): with pytest . raises ( TypeMismatch ): value = string_from_key ( dictionary = self . dictionary , key = \"key2\" ) assert not isinstance ( value , str )","title":"Test comparison"},{"location":"install/","text":"Installation is as simple as: $ pip install meiga ---> 100% Successfully installed meiga This will install the latest version of meiga package \u270c\ufe0f Requirements \u00b6 This packages only requires typing-extensions for Python versions lower than 3.10 .","title":"Install"},{"location":"install/#requirements","text":"This packages only requires typing-extensions for Python versions lower than 3.10 .","title":"Requirements"},{"location":"usage/alias/","text":"Use meiga aliases to improve the semantics of your code. Check out the meiga available alias: Alias Definition Success(value) Equivalent to Result(success=value) Failure(value) Equivalent to Result(failure=error_instance) isSuccess Equivalent to Result(success=True) isFailure Equivalent to Result(failure=Error()) NotImplementedMethodError Useful to define abstract methods on interfaces given semantic to your code BoolResult Equivalent to Result[bool, Error] AnyResult Equivalent to Result[Any, Error] Success \u00b6 For success result you can use: from meiga import Success result = Success ( \"Rosalia\" ) # the equivalent of Result(success=\"Rosalia\") If you want to return a true bool value, you can use the following equivalent expressions: from meiga import Success , isSuccess result = Success () result = Success ( True ) result = isSuccess Failure \u00b6 For failure results: from meiga import Failure , Error class NoSuchKey ( Error ): ... result = Failure ( NoSuchKey ()) # the equivalent of Result(failure=NoSuchKey()) If you don't want to specify the error, you can use a default value with the following equivalent expressions: from meiga import Failure , Error , isFailure result = Failure () result = Failure ( Error ()) result = isFailure # Only valid for a failure result with non-specific Error() value Example If we review the previous example back Getting Started . We were using already the alias to improve the expressivity of our code: from __future__ import annotations from meiga import Result , Error , Success , Failure class NoSuchKey ( Error ): ... class TypeMismatch ( Error ): ... def string_from_key ( dictionary : dict , key : str ) -> Result [ str , NoSuchKey | TypeMismatch ]: if key not in dictionary . keys (): return Failure ( NoSuchKey ()) value = dictionary [ key ] if not isinstance ( value , str ): return Failure ( TypeMismatch ()) return Success ( value ) NotImplementedMethodError \u00b6 Furthermore, there is an available a useful alias: NotImplementedMethodError Use it when define abstract method that returns Result type from meiga import Result , Error , NotImplementedMethodError from abc import ABC , abstractmethod class AuthService ( ABC ): def __init__ ( self , base_url : str ): self . base_url = base_url @abstractmethod def create_token ( self , client : str , client_id : str ) -> Result [ str , Error ]: return NotImplementedMethodError","title":"Alias"},{"location":"usage/alias/#success","text":"For success result you can use: from meiga import Success result = Success ( \"Rosalia\" ) # the equivalent of Result(success=\"Rosalia\") If you want to return a true bool value, you can use the following equivalent expressions: from meiga import Success , isSuccess result = Success () result = Success ( True ) result = isSuccess","title":"Success"},{"location":"usage/alias/#failure","text":"For failure results: from meiga import Failure , Error class NoSuchKey ( Error ): ... result = Failure ( NoSuchKey ()) # the equivalent of Result(failure=NoSuchKey()) If you don't want to specify the error, you can use a default value with the following equivalent expressions: from meiga import Failure , Error , isFailure result = Failure () result = Failure ( Error ()) result = isFailure # Only valid for a failure result with non-specific Error() value Example If we review the previous example back Getting Started . We were using already the alias to improve the expressivity of our code: from __future__ import annotations from meiga import Result , Error , Success , Failure class NoSuchKey ( Error ): ... class TypeMismatch ( Error ): ... def string_from_key ( dictionary : dict , key : str ) -> Result [ str , NoSuchKey | TypeMismatch ]: if key not in dictionary . keys (): return Failure ( NoSuchKey ()) value = dictionary [ key ] if not isinstance ( value , str ): return Failure ( TypeMismatch ()) return Success ( value )","title":"Failure"},{"location":"usage/alias/#notimplementedmethoderror","text":"Furthermore, there is an available a useful alias: NotImplementedMethodError Use it when define abstract method that returns Result type from meiga import Result , Error , NotImplementedMethodError from abc import ABC , abstractmethod class AuthService ( ABC ): def __init__ ( self , base_url : str ): self . base_url = base_url @abstractmethod def create_token ( self , client : str , client_id : str ) -> Result [ str , Error ]: return NotImplementedMethodError","title":"NotImplementedMethodError"},{"location":"usage/assertions/","text":"Result assertion may help us on testing functions. meiga provide us two functions: assert_success and access_failure . How to assert \u00b6 Following the example given on the getting started section: With meiga \ud83e\uddd9 Without meiga \ud83d\ude14 import pytest from tests.unit.doc.example_without_meiga import ( NoSuchKey , TypeMismatch , string_from_key , ) @pytest . mark . unit class TestExampleWithMeiga : dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } def should_success ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"key1\" ) result . assert_success ( value_is_instance_of = str ) def should_fail_when_key_does_not_exist ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"invalid_key\" ) result . assert_failure ( value_is_instance_of = NoSuchKey ) def should_fail_when_type_mismatch ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"key2\" ) result . assert_failure ( value_is_instance_of = TypeMismatch ) import pytest from tests.unit.doc.example_without_meiga import ( NoSuchKey , TypeMismatch , string_from_key , ) @pytest . mark . unit class TestExampleWithoutMeiga : dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } def should_return_a_str ( self ): value = string_from_key ( dictionary = self . dictionary , key = \"key1\" ) assert isinstance ( value , str ) def should_raises_non_such_key_exception ( self ): with pytest . raises ( NoSuchKey ): _ = string_from_key ( dictionary = self . dictionary , key = \"invalid_key\" ) def should_raises_type_mismatch_exception ( self ): with pytest . raises ( TypeMismatch ): value = string_from_key ( dictionary = self . dictionary , key = \"key2\" ) assert not isinstance ( value , str ) Note Check the following pytest-based test for more information: tests/unit/test_result_assertions.py Warning Before the version 1.7.0 , the only way to assert results is with from meiga.assertions import assert_success, assert_failure . import pytest from meiga.assertions import assert_success , assert_failure from meiga import Result @pytest . mark . unit class TestResultAssertion : def should_assert_a_success ( self ): result = Result ( success = 5 ) assert_success ( result , value_is_instance_of = int ) For the shake of compatibility, this way of assertion is also supported. However, we strongly recommend to use Result class to perform auto assertion avoiding also import from meiga.assertions module.","title":"Assertions"},{"location":"usage/assertions/#how-to-assert","text":"Following the example given on the getting started section: With meiga \ud83e\uddd9 Without meiga \ud83d\ude14 import pytest from tests.unit.doc.example_without_meiga import ( NoSuchKey , TypeMismatch , string_from_key , ) @pytest . mark . unit class TestExampleWithMeiga : dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } def should_success ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"key1\" ) result . assert_success ( value_is_instance_of = str ) def should_fail_when_key_does_not_exist ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"invalid_key\" ) result . assert_failure ( value_is_instance_of = NoSuchKey ) def should_fail_when_type_mismatch ( self ): result = string_from_key ( dictionary = self . dictionary , key = \"key2\" ) result . assert_failure ( value_is_instance_of = TypeMismatch ) import pytest from tests.unit.doc.example_without_meiga import ( NoSuchKey , TypeMismatch , string_from_key , ) @pytest . mark . unit class TestExampleWithoutMeiga : dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } def should_return_a_str ( self ): value = string_from_key ( dictionary = self . dictionary , key = \"key1\" ) assert isinstance ( value , str ) def should_raises_non_such_key_exception ( self ): with pytest . raises ( NoSuchKey ): _ = string_from_key ( dictionary = self . dictionary , key = \"invalid_key\" ) def should_raises_type_mismatch_exception ( self ): with pytest . raises ( TypeMismatch ): value = string_from_key ( dictionary = self . dictionary , key = \"key2\" ) assert not isinstance ( value , str ) Note Check the following pytest-based test for more information: tests/unit/test_result_assertions.py Warning Before the version 1.7.0 , the only way to assert results is with from meiga.assertions import assert_success, assert_failure . import pytest from meiga.assertions import assert_success , assert_failure from meiga import Result @pytest . mark . unit class TestResultAssertion : def should_assert_a_success ( self ): result = Result ( success = 5 ) assert_success ( result , value_is_instance_of = int ) For the shake of compatibility, this way of assertion is also supported. However, we strongly recommend to use Result class to perform auto assertion avoiding also import from meiga.assertions module.","title":"How to assert"},{"location":"usage/decorators/","text":"Use decorators to protect your results and prevent from unexpected exceptions. They always return a Result object. to_result \u00b6 Use @to_result to wrap a function transforming returned value in a Success and raised Exceptions in a Failure . from meiga import to_result , Result , Error class NoSuchKey ( Exception ): ... class TypeMismatch ( Exception ): ... @to_result def string_from_key ( dictionary : dict , key : str ) -> str : if key not in dictionary . keys (): raise NoSuchKey () value = dictionary [ key ] if not isinstance ( value , str ): raise TypeMismatch () return value dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } key = \"key1\" result : Result [ str , Error ] = string_from_key ( dictionary = dictionary , key = key ) early_return \u00b6 Use @early_return decoration in combination with unwrap_or_return() . The unwrap_or_return will unwrap the value of the Result monad only if it is a success. Otherwise, this will return a Failure (Result with a failure) when using @early_return decorator. from meiga import early_return , BoolResult , isSuccess @early_return def update_user ( user_id : UserId , new_name : str ) -> BoolResult : user = repository . retrieve ( user_id ) . unwrap_or_return () user . update_name ( new_name ) repository . save ( user ) . unwrap_or_return () event_bus . publish ( user . pull_domain_events ()) . unwrap_or_return () return isSuccess Given a user repository with a method retrieve which returns a typed Result[User, UserNotFoundError] , when we unwrap_or_return , we will unwrap the value of returned Result in case of Success. On the other side, when retrieve function with not valid UserId , the repository automatically returns a result failure interrupting the execution of the following lines of code. Note This is possible because the unwrap_or_return function will raise an specific exception ( OnFailureException ) if the result is a failure an cannot be wrapped: def unwrap_or_return ( self , return_value_on_failure : Any = None ) -> TS : if not self . _is_success : return_value = ( self if return_value_on_failure is None else return_value_on_failure ) raise OnFailureException ( return_value ) return cast ( TS , self . value ) And @early_return decorator catches the exception and coverts it to a Result : P = ParamSpec ( \"P\" ) R = TypeVar ( \"R\" , bound = Result ) def early_return ( func : Callable [ P , R ]) -> Callable [ P , R ]: @wraps ( func ) def _early_return ( * args : P . args , ** kwargs : P . kwargs ) -> R : try : if isinstance ( func , staticmethod ): return Failure ( UnexpectedDecorationOrderError ()) elif isinstance ( func , classmethod ): return Failure ( UnexpectedDecorationOrderError ()) else : return func ( * args , ** kwargs ) except OnFailureException as exc : return exc . result except Error as error : return cast ( R , Failure ( error )) return _early_return Warning When decorate staticmethod and classmethod check the order, otherwise it will raise an error (UnexpectedDecorationOrderError) as these kinds of methods are not callable. from meiga import early_return class UserCreatorFactory : @staticmethod @early_return def from_version ( version : str ) -> Result [ UserCreator , Error ]: if version == \"migration_v1\" : creator = UserCreator . build () else : creator = LegacyUserCreator . build () return Success ( creator ) async_early_return \u00b6 Use @async_early_return decoration in combination with unwrap_or_return() when using async functions. from meiga import async_early_return , BoolResult , isSuccess @async_early_return async def update_user ( user_id : UserId , new_name : str ) -> BoolResult : user = ( await repository . retrieve ( user_id )) . unwrap_or_return () user . update_name ( new_name ) ( await repository . save ( user )) . unwrap_or_return () ( await event_bus . publish ( user . pull_domain_events ())) . unwrap_or_return () return isSuccess","title":"Decorators"},{"location":"usage/decorators/#to_result","text":"Use @to_result to wrap a function transforming returned value in a Success and raised Exceptions in a Failure . from meiga import to_result , Result , Error class NoSuchKey ( Exception ): ... class TypeMismatch ( Exception ): ... @to_result def string_from_key ( dictionary : dict , key : str ) -> str : if key not in dictionary . keys (): raise NoSuchKey () value = dictionary [ key ] if not isinstance ( value , str ): raise TypeMismatch () return value dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } key = \"key1\" result : Result [ str , Error ] = string_from_key ( dictionary = dictionary , key = key )","title":"to_result"},{"location":"usage/decorators/#early_return","text":"Use @early_return decoration in combination with unwrap_or_return() . The unwrap_or_return will unwrap the value of the Result monad only if it is a success. Otherwise, this will return a Failure (Result with a failure) when using @early_return decorator. from meiga import early_return , BoolResult , isSuccess @early_return def update_user ( user_id : UserId , new_name : str ) -> BoolResult : user = repository . retrieve ( user_id ) . unwrap_or_return () user . update_name ( new_name ) repository . save ( user ) . unwrap_or_return () event_bus . publish ( user . pull_domain_events ()) . unwrap_or_return () return isSuccess Given a user repository with a method retrieve which returns a typed Result[User, UserNotFoundError] , when we unwrap_or_return , we will unwrap the value of returned Result in case of Success. On the other side, when retrieve function with not valid UserId , the repository automatically returns a result failure interrupting the execution of the following lines of code. Note This is possible because the unwrap_or_return function will raise an specific exception ( OnFailureException ) if the result is a failure an cannot be wrapped: def unwrap_or_return ( self , return_value_on_failure : Any = None ) -> TS : if not self . _is_success : return_value = ( self if return_value_on_failure is None else return_value_on_failure ) raise OnFailureException ( return_value ) return cast ( TS , self . value ) And @early_return decorator catches the exception and coverts it to a Result : P = ParamSpec ( \"P\" ) R = TypeVar ( \"R\" , bound = Result ) def early_return ( func : Callable [ P , R ]) -> Callable [ P , R ]: @wraps ( func ) def _early_return ( * args : P . args , ** kwargs : P . kwargs ) -> R : try : if isinstance ( func , staticmethod ): return Failure ( UnexpectedDecorationOrderError ()) elif isinstance ( func , classmethod ): return Failure ( UnexpectedDecorationOrderError ()) else : return func ( * args , ** kwargs ) except OnFailureException as exc : return exc . result except Error as error : return cast ( R , Failure ( error )) return _early_return Warning When decorate staticmethod and classmethod check the order, otherwise it will raise an error (UnexpectedDecorationOrderError) as these kinds of methods are not callable. from meiga import early_return class UserCreatorFactory : @staticmethod @early_return def from_version ( version : str ) -> Result [ UserCreator , Error ]: if version == \"migration_v1\" : creator = UserCreator . build () else : creator = LegacyUserCreator . build () return Success ( creator )","title":"early_return"},{"location":"usage/decorators/#async_early_return","text":"Use @async_early_return decoration in combination with unwrap_or_return() when using async functions. from meiga import async_early_return , BoolResult , isSuccess @async_early_return async def update_user ( user_id : UserId , new_name : str ) -> BoolResult : user = ( await repository . retrieve ( user_id )) . unwrap_or_return () user . update_name ( new_name ) ( await repository . save ( user )) . unwrap_or_return () ( await event_bus . publish ( user . pull_domain_events ())) . unwrap_or_return () return isSuccess","title":"async_early_return"},{"location":"usage/result/","text":"Result[T, Error] \ud83d\udc49 A discriminated union that encapsulates successful outcome with a value of type T or a failure with an arbitrary Error exception. Functions \u00b6 Functions Definition unwrap() Returns the encapsulated value if this instance is a success or None if it is failure. unwrap_or_raise() Returns the encapsulated value if this instance is a success or raise the encapsulated exception if it is failure. unwrap_or_return() Returns the encapsulated value if this instance is a success or return Result as long as @early_return decorator wraps the function. unwrap_or(failure_value) Returns the encapsulated value if this instance is a success or the selected failure_value if it is failure. reraise() Raises the encapsulated failure value if this instance derive from Error or BaseException. map() Modifies encapsulate value applying a mapper function. unwrap_or_else(on_failure_handler) Returns the encapsulated value if this instance is a success or execute the on_failure_handler when it is failure. unwrap_and(on_success_handler) Returns the encapsulated value if this instance is a success and execute the on_success_handler when it is success. handle(on_success_handler,on_failure_handler) Returns itself and execute the on_success_handler when the instance is a success and the on_failure_handler when it is failure. bind(func) Returns itself binding success value with input func transform() Transform the result with a transformer function. You can give the transformer callable or use the set_transformer function to pre-set the callable to be used. Properties \u00b6 Properties Definition value Returns the encapsulated value whether it's success or failure is_success Returns true if this instance represents successful outcome. In this case is_failure returns false. is_failure Returns true if this instance represents failed outcome. In this case is_success returns false Introduction \u00b6 Let's imagine we have a dictionary that represent a user info data and we use the string_from_key (presented in the Getting Started section before) to retrieve the first name of the user. user_info = { \"first_name\" : \"Rosalia\" , \"last_name\" : \"De Castro\" , \"age\" : 60 } result = string_from_key ( dictionary = user_info , key = \"first_name\" ) # \u27a1 Result will be Result[status: success | value: Rosalia] You could also check the status of the result is_success = result . is_success # \u27a1\ufe0f It will return True is_failure = result . is_failure # \u27a1\ufe0f It will return False If the result is a success you can get the expected value accessing the property value or using the unwrap function (recommended). my_value = result . value # \u27a1\ufe0f It will return Rosalia my_value = result . unwrap () # \u27a1\ufe0f It will return also Rosalia Otherwise, if we try to access an invalid key or a non string value, returned result will be a failure. result = string_from_key ( dictionary = user_info , key = \"invalid_key\" ) # \u27a1 Result will be Result[status: failure | value: NoSuchKey] is_success = result . is_success # \u27a1\ufe0f It will return False is_failure = result . is_failure # \u27a1\ufe0f It will return True my_value = result . value # \u27a1\ufe0f It will return NoSuchKey (Error) my_value = result . unwrap () # \u27a1\ufe0f It will return also NoSuchKey (Error) Or result = string_from_key ( dictionary = user_info , key = \"age\" ) # \u27a1 Result will be Result[status: failure | value: TypeMismatch] is_success = result . is_success # \u27a1\ufe0f It will return False is_failure = result . is_failure # \u27a1\ufe0f It will return True my_value = result . value # \u27a1\ufe0f It will return TypeMismatch (Error) my_value = result . unwrap () # \u27a1\ufe0f It will return also TypeMismatch (Error) Detail \u00b6 We will present some tips and examples to see in detail what meiga can offer us. unwrap \u00b6 Returns the encapsulated value if this instance is a success or None if it is failure. Example If you unwrap a Result object, it will return a valid value if it is success. Otherwise, it will return None. result = Result ( success = \"Hi!\" ) value = result . unwrap () # \u27a1\ufe0f It will return \"Hi!\" result = Failure ( Error ()) value = result . unwrap () # \u27a1\ufe0f It will return None See tests/unit/test_result_unwrap.py to see examples of usage. unwrap_or_raise \u00b6 Returns the encapsulated value if this instance is a success or raises the encapsulated exception if it is failure. Example result = Result ( success = \"Hi!\" ) value = result . unwrap_or_raise () # \u27a1\ufe0f It will return \"Hi!\" result = Failure ( Error ()) value = result . unwrap_or_raise () # \u27a1\ufe0f It will raise an exception using given Error instance unwrap_or_return \u00b6 Returns the encapsulated value if this instance is a success or return Result as long as @early_return decorator wraps the function. Example Use unwrap_or_return in combination with @early_return decorator. If something wrong happens unwrapping your Result , the unwrap_or_return function will raise an controlled Exception ( WaitingForEarlyReturn ). @early_return decorator will handle the exception and unwrap the value in case of success. The following example illustrate this: from meiga import Result , Error , early_return @early_return def handling_result ( key : str ) -> Result : user_info = { \"first_name\" : \"Rosalia\" , \"last_name\" : \"De Castro\" , \"age\" : 60 } first_name = string_from_key ( dictionary = user_info , key = key ) . unwrap_or_return () # Do whatever with the name name = first_name . lower () return Result ( success = name ) If key is valid success value would be returned. Otherwise, an Error would be returned. If you need to return a specific value if fails, you can do it with meiga: first_name = string_from_key ( dictionary = user_info , key = key ) . unwrap_or_return ( return_value_on_failure = MyError ()) unwrap_or \u00b6 Returns the encapsulated value if this instance is a success or the selected failure_value if it is failure. Example first_name = string_from_key ( dictionary = user_info , key = key ) . unwrap_or ( failure_value = \"UserWithoutName\" ) # It will return the first name if success or \"UserWithoutName\" if failure reraise \u00b6 Raises the encapsulated failure value if this instance inherits from Error or BaseException. Example result = Success ( \"Hi!\" ) result . reraise () # \u27a1\ufe0f It won't raise an exception as is a success. So, this will return None result = Failure ( Error ()) result . reraise () # \u27a1\ufe0f It will throw an exception using given Error instance map \u00b6 Modifies encapsulate value applying a mapper function. Example def capitalize ( value ): return value . capitalize () first_name = string_from_key ( dictionary = user_info , key = key ) first_name . map ( capitalize ) unwrap_or_else \u00b6 Returns the encapsulated value if this instance is a success or execute the on_failure_handler when it is failure. Example from meiga import OnFailureHandler def on_failure_func (): print ( \"Do your staff here to react to a failure\" ) first_name : str = string_from_key ( dictionary = user_info , key = key ) . unwrap_or_else ( on_failure_handler = OnFailureHandler ( func = failure_handler )) unwrap_and \u00b6 Returns the encapsulated value if this instance is a success and execute the on_success_handler when it is success. Example from meiga import OnSuccessHandler def on_success_func (): print ( \"Do your staff here to react to a success\" ) first_name : str = string_from_key ( dictionary = user_info , key = key ) . unwrap_and ( on_success_handler = OnSuccessHandler ( func = on_success_func )) handle \u00b6 Returns itself and execute the on_success_handler when the instance is a success and the on_failure_handler when it is failure. Example You can call another function after evaluate the result. Use optional parameters success_handler and failure_handler (Callable functions). from meiga import OnSuccessHandler , OnFailureHandler def success_handler (): print ( \"Do my successful stuff here!\" ) def failure_handler (): print ( \"Do my failure stuff here!\" ) result = string_from_key ( dictionary = user_info , key = \"first_name\" ) result . handle ( on_success_handler = OnSuccessHandler ( func = success_handler ), on_failure_handler = OnFailureHandler ( func = failure_handler ) ) Tip: Additional parameters If you need to add some arguments as a parameters, use success_args and failure_args : from meiga import OnSuccessHandler , OnFailureHandler def success_handler ( param_1 ): print ( f \"param_1: { param_1 } \" ) def failure_handler ( param_1 , param_2 ): print ( f \"param_1: { param_1 } \" ) print ( f \"param_2: { param_2 } \" ) result = string_from_key ( dictionary = user_info , key = \"first_name\" ) result . handle ( on_success_handler = OnSuccessHandler ( func = success_handler , args = ( 1 ,)), on_failure_handler = OnFailureHandler ( func = failure_handler , args = ( 1 , 2 )) ) Tip: Additional parameters in combination with the Result itself Sometimes a handle function will need information about external parameters and also about the result itself. Now, is possible this combination thanks to Result.__id__ identifier. from meiga import Result , Error , OnSuccessHandler , OnFailureHandler args = ( 1 , Result . __id__ , 2 ) def success_handler ( param_1 : int , result : Result , param_2 : int ): assert param_1 == 1 assert isinstance ( result , Result ) assert result . value is True assert param_2 == 2 def failure_handler ( param_1 : int , result : Result , param_2 : int ): assert param_1 == 1 assert isinstance ( result , Result ) assert result . value == Error () assert param_2 == 2 def run ( result : Result ): result . handle ( on_success_handler = OnSuccessHandler ( func = success_handler , args = args ), on_failure_handler = OnFailureHandler ( func = failure_handler , args = args ) ) run ( result ) bind \u00b6 Returns itself binding success value with input func Question What's the difference with handle? It's quite similar but simpler. Bind only be applied to success value and don't accept external arguments This function is very convenient for chaining actions on a result. from typing import Any from meiga import Success user = { \"name\" : \"rosalia de castro\" , \"age\" : 186 } result = Success ( user ) def upper_name ( value : Any ) -> Any : value . update ({ \"name\" : value [ \"name\" ] . upper ()}) return value def update_age ( value : Any ) -> Any : value . update ({ \"age\" : value [ \"age\" ] + 1 }) return value def add_location ( value : Any ) -> Any : value . update ({ \"location\" : \"GALIZA\" }) return value result = ( result . bind ( upper_name ) . bind ( update_age ) . bind ( add_location ) ) transform \u00b6 Transform the result with a transformer function. You can give the transformer callable or use the set_transformer function to pre-set the callable to be used. You can define a transformer to capitalize the value in case of success and raise an from meiga import Result , Success , Failure def transformer ( result : Result ) -> tuple [ int , str ]: match result : case Success ( value ): return 200 , value . capitalize () case Failure ( error ): raise 500 , \"error\" result = Success ( \"value\" ) status_code , message = result . transform ( transformer ) In addition, you can set a transformer in an inner function that will be used in the future to transform the Result . from meiga import Result , Error , Success , Failure def my_controller () -> Result [ str , Error ] def transformer ( result : Result ) -> tuple [ int , str ]: match result : case Success ( value ): return 200 , value . capitalize () case Failure ( error ): raise 500 , \"error\" result = Success ( \"value\" ) result . set_transformer ( transformer ) result = my_controller () status_code , message = result . transform () # (1) Use trasformer function set with set_transformer . match \u00b6 Python > 3.10 If you are using Python 3.10 or above , you can take advantage of new syntax proposed in PEP 636 \u2013 Structural Pattern Matching to handle the result. from __future__ import annotations from meiga import Error , Failure , Result , Success class NoSuchKey ( Error ): ... class TypeMismatch ( Error ): ... def string_from_key ( dictionary : dict , key : str ) -> Result [ str , NoSuchKey | TypeMismatch ]: if key not in dictionary . keys (): return Failure ( NoSuchKey ()) value = dictionary [ key ] if not isinstance ( value , str ): return Failure ( TypeMismatch ()) return Success ( value ) dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } for key in [ \"key1\" , \"key2\" , \"key3\" ]: result = string_from_key ( dictionary = dictionary , key = key ) match result : case Success ( _ ): print ( f \"Success\" ) case Failure ( NoSuchKey ()): print ( \"Failure with NoSuchKey\" ) case Failure ( TypeMismatch ()): print ( \"Failure with TypeMismatch\" ) case _ : print ( \"default\" ) Warning If are using Result(success=\"my_success\") and Result(failure=NoSuchKey()) syntax intead of recommended one with Success and Failure aliases, you have to use a different match pattern. You would have to use something like: match result : case Result ( str (), _ ): print ( f \"Success\" ) case Result ( _ , NoSuchKey ()): print ( \"Failure with NoSuchKey\" ) case Result ( _ , TypeMismatch ()): print ( \"Failure with TypeMismatch\" ) case _ : print ( \"default\" ) Check this closed issue to learn more about the PEP 636 and this usage in the meiga library. Deprecated \u26a0\ufe0f \u00b6 throw \u00b6 Throws the encapsulated failure value if this instance inherits from Error or BaseException. Example result = Success ( \"Hi!\" ) result . throw () # \u27a1\ufe0f It won't throw an exception as is a success. So, this will return None result = Failure ( Error ()) result . throw () # \u27a1\ufe0f It will throw an exception using given Error instance unwrap_or_throw \u00b6 Returns the encapsulated value if this instance is a success or throws the encapsulated exception if it is failure. Example result = Result ( success = \"Hi!\" ) value = result . unwrap_or_throw () # \u27a1\ufe0f It will return \"Hi!\" result = Failure ( Error ()) value = result . unwrap_or_throw () # \u27a1\ufe0f It will throw an exception using given Error instance","title":"Result"},{"location":"usage/result/#functions","text":"Functions Definition unwrap() Returns the encapsulated value if this instance is a success or None if it is failure. unwrap_or_raise() Returns the encapsulated value if this instance is a success or raise the encapsulated exception if it is failure. unwrap_or_return() Returns the encapsulated value if this instance is a success or return Result as long as @early_return decorator wraps the function. unwrap_or(failure_value) Returns the encapsulated value if this instance is a success or the selected failure_value if it is failure. reraise() Raises the encapsulated failure value if this instance derive from Error or BaseException. map() Modifies encapsulate value applying a mapper function. unwrap_or_else(on_failure_handler) Returns the encapsulated value if this instance is a success or execute the on_failure_handler when it is failure. unwrap_and(on_success_handler) Returns the encapsulated value if this instance is a success and execute the on_success_handler when it is success. handle(on_success_handler,on_failure_handler) Returns itself and execute the on_success_handler when the instance is a success and the on_failure_handler when it is failure. bind(func) Returns itself binding success value with input func transform() Transform the result with a transformer function. You can give the transformer callable or use the set_transformer function to pre-set the callable to be used.","title":"Functions"},{"location":"usage/result/#properties","text":"Properties Definition value Returns the encapsulated value whether it's success or failure is_success Returns true if this instance represents successful outcome. In this case is_failure returns false. is_failure Returns true if this instance represents failed outcome. In this case is_success returns false","title":"Properties"},{"location":"usage/result/#introduction","text":"Let's imagine we have a dictionary that represent a user info data and we use the string_from_key (presented in the Getting Started section before) to retrieve the first name of the user. user_info = { \"first_name\" : \"Rosalia\" , \"last_name\" : \"De Castro\" , \"age\" : 60 } result = string_from_key ( dictionary = user_info , key = \"first_name\" ) # \u27a1 Result will be Result[status: success | value: Rosalia] You could also check the status of the result is_success = result . is_success # \u27a1\ufe0f It will return True is_failure = result . is_failure # \u27a1\ufe0f It will return False If the result is a success you can get the expected value accessing the property value or using the unwrap function (recommended). my_value = result . value # \u27a1\ufe0f It will return Rosalia my_value = result . unwrap () # \u27a1\ufe0f It will return also Rosalia Otherwise, if we try to access an invalid key or a non string value, returned result will be a failure. result = string_from_key ( dictionary = user_info , key = \"invalid_key\" ) # \u27a1 Result will be Result[status: failure | value: NoSuchKey] is_success = result . is_success # \u27a1\ufe0f It will return False is_failure = result . is_failure # \u27a1\ufe0f It will return True my_value = result . value # \u27a1\ufe0f It will return NoSuchKey (Error) my_value = result . unwrap () # \u27a1\ufe0f It will return also NoSuchKey (Error) Or result = string_from_key ( dictionary = user_info , key = \"age\" ) # \u27a1 Result will be Result[status: failure | value: TypeMismatch] is_success = result . is_success # \u27a1\ufe0f It will return False is_failure = result . is_failure # \u27a1\ufe0f It will return True my_value = result . value # \u27a1\ufe0f It will return TypeMismatch (Error) my_value = result . unwrap () # \u27a1\ufe0f It will return also TypeMismatch (Error)","title":"Introduction"},{"location":"usage/result/#detail","text":"We will present some tips and examples to see in detail what meiga can offer us.","title":"Detail"},{"location":"usage/result/#unwrap","text":"Returns the encapsulated value if this instance is a success or None if it is failure. Example If you unwrap a Result object, it will return a valid value if it is success. Otherwise, it will return None. result = Result ( success = \"Hi!\" ) value = result . unwrap () # \u27a1\ufe0f It will return \"Hi!\" result = Failure ( Error ()) value = result . unwrap () # \u27a1\ufe0f It will return None See tests/unit/test_result_unwrap.py to see examples of usage.","title":"unwrap"},{"location":"usage/result/#unwrap_or_raise","text":"Returns the encapsulated value if this instance is a success or raises the encapsulated exception if it is failure. Example result = Result ( success = \"Hi!\" ) value = result . unwrap_or_raise () # \u27a1\ufe0f It will return \"Hi!\" result = Failure ( Error ()) value = result . unwrap_or_raise () # \u27a1\ufe0f It will raise an exception using given Error instance","title":"unwrap_or_raise"},{"location":"usage/result/#unwrap_or_return","text":"Returns the encapsulated value if this instance is a success or return Result as long as @early_return decorator wraps the function. Example Use unwrap_or_return in combination with @early_return decorator. If something wrong happens unwrapping your Result , the unwrap_or_return function will raise an controlled Exception ( WaitingForEarlyReturn ). @early_return decorator will handle the exception and unwrap the value in case of success. The following example illustrate this: from meiga import Result , Error , early_return @early_return def handling_result ( key : str ) -> Result : user_info = { \"first_name\" : \"Rosalia\" , \"last_name\" : \"De Castro\" , \"age\" : 60 } first_name = string_from_key ( dictionary = user_info , key = key ) . unwrap_or_return () # Do whatever with the name name = first_name . lower () return Result ( success = name ) If key is valid success value would be returned. Otherwise, an Error would be returned. If you need to return a specific value if fails, you can do it with meiga: first_name = string_from_key ( dictionary = user_info , key = key ) . unwrap_or_return ( return_value_on_failure = MyError ())","title":"unwrap_or_return"},{"location":"usage/result/#unwrap_or","text":"Returns the encapsulated value if this instance is a success or the selected failure_value if it is failure. Example first_name = string_from_key ( dictionary = user_info , key = key ) . unwrap_or ( failure_value = \"UserWithoutName\" ) # It will return the first name if success or \"UserWithoutName\" if failure","title":"unwrap_or"},{"location":"usage/result/#reraise","text":"Raises the encapsulated failure value if this instance inherits from Error or BaseException. Example result = Success ( \"Hi!\" ) result . reraise () # \u27a1\ufe0f It won't raise an exception as is a success. So, this will return None result = Failure ( Error ()) result . reraise () # \u27a1\ufe0f It will throw an exception using given Error instance","title":"reraise"},{"location":"usage/result/#map","text":"Modifies encapsulate value applying a mapper function. Example def capitalize ( value ): return value . capitalize () first_name = string_from_key ( dictionary = user_info , key = key ) first_name . map ( capitalize )","title":"map"},{"location":"usage/result/#unwrap_or_else","text":"Returns the encapsulated value if this instance is a success or execute the on_failure_handler when it is failure. Example from meiga import OnFailureHandler def on_failure_func (): print ( \"Do your staff here to react to a failure\" ) first_name : str = string_from_key ( dictionary = user_info , key = key ) . unwrap_or_else ( on_failure_handler = OnFailureHandler ( func = failure_handler ))","title":"unwrap_or_else"},{"location":"usage/result/#unwrap_and","text":"Returns the encapsulated value if this instance is a success and execute the on_success_handler when it is success. Example from meiga import OnSuccessHandler def on_success_func (): print ( \"Do your staff here to react to a success\" ) first_name : str = string_from_key ( dictionary = user_info , key = key ) . unwrap_and ( on_success_handler = OnSuccessHandler ( func = on_success_func ))","title":"unwrap_and"},{"location":"usage/result/#handle","text":"Returns itself and execute the on_success_handler when the instance is a success and the on_failure_handler when it is failure. Example You can call another function after evaluate the result. Use optional parameters success_handler and failure_handler (Callable functions). from meiga import OnSuccessHandler , OnFailureHandler def success_handler (): print ( \"Do my successful stuff here!\" ) def failure_handler (): print ( \"Do my failure stuff here!\" ) result = string_from_key ( dictionary = user_info , key = \"first_name\" ) result . handle ( on_success_handler = OnSuccessHandler ( func = success_handler ), on_failure_handler = OnFailureHandler ( func = failure_handler ) ) Tip: Additional parameters If you need to add some arguments as a parameters, use success_args and failure_args : from meiga import OnSuccessHandler , OnFailureHandler def success_handler ( param_1 ): print ( f \"param_1: { param_1 } \" ) def failure_handler ( param_1 , param_2 ): print ( f \"param_1: { param_1 } \" ) print ( f \"param_2: { param_2 } \" ) result = string_from_key ( dictionary = user_info , key = \"first_name\" ) result . handle ( on_success_handler = OnSuccessHandler ( func = success_handler , args = ( 1 ,)), on_failure_handler = OnFailureHandler ( func = failure_handler , args = ( 1 , 2 )) ) Tip: Additional parameters in combination with the Result itself Sometimes a handle function will need information about external parameters and also about the result itself. Now, is possible this combination thanks to Result.__id__ identifier. from meiga import Result , Error , OnSuccessHandler , OnFailureHandler args = ( 1 , Result . __id__ , 2 ) def success_handler ( param_1 : int , result : Result , param_2 : int ): assert param_1 == 1 assert isinstance ( result , Result ) assert result . value is True assert param_2 == 2 def failure_handler ( param_1 : int , result : Result , param_2 : int ): assert param_1 == 1 assert isinstance ( result , Result ) assert result . value == Error () assert param_2 == 2 def run ( result : Result ): result . handle ( on_success_handler = OnSuccessHandler ( func = success_handler , args = args ), on_failure_handler = OnFailureHandler ( func = failure_handler , args = args ) ) run ( result )","title":"handle"},{"location":"usage/result/#bind","text":"Returns itself binding success value with input func Question What's the difference with handle? It's quite similar but simpler. Bind only be applied to success value and don't accept external arguments This function is very convenient for chaining actions on a result. from typing import Any from meiga import Success user = { \"name\" : \"rosalia de castro\" , \"age\" : 186 } result = Success ( user ) def upper_name ( value : Any ) -> Any : value . update ({ \"name\" : value [ \"name\" ] . upper ()}) return value def update_age ( value : Any ) -> Any : value . update ({ \"age\" : value [ \"age\" ] + 1 }) return value def add_location ( value : Any ) -> Any : value . update ({ \"location\" : \"GALIZA\" }) return value result = ( result . bind ( upper_name ) . bind ( update_age ) . bind ( add_location ) )","title":"bind"},{"location":"usage/result/#transform","text":"Transform the result with a transformer function. You can give the transformer callable or use the set_transformer function to pre-set the callable to be used. You can define a transformer to capitalize the value in case of success and raise an from meiga import Result , Success , Failure def transformer ( result : Result ) -> tuple [ int , str ]: match result : case Success ( value ): return 200 , value . capitalize () case Failure ( error ): raise 500 , \"error\" result = Success ( \"value\" ) status_code , message = result . transform ( transformer ) In addition, you can set a transformer in an inner function that will be used in the future to transform the Result . from meiga import Result , Error , Success , Failure def my_controller () -> Result [ str , Error ] def transformer ( result : Result ) -> tuple [ int , str ]: match result : case Success ( value ): return 200 , value . capitalize () case Failure ( error ): raise 500 , \"error\" result = Success ( \"value\" ) result . set_transformer ( transformer ) result = my_controller () status_code , message = result . transform () # (1) Use trasformer function set with set_transformer .","title":"transform"},{"location":"usage/result/#match","text":"Python > 3.10 If you are using Python 3.10 or above , you can take advantage of new syntax proposed in PEP 636 \u2013 Structural Pattern Matching to handle the result. from __future__ import annotations from meiga import Error , Failure , Result , Success class NoSuchKey ( Error ): ... class TypeMismatch ( Error ): ... def string_from_key ( dictionary : dict , key : str ) -> Result [ str , NoSuchKey | TypeMismatch ]: if key not in dictionary . keys (): return Failure ( NoSuchKey ()) value = dictionary [ key ] if not isinstance ( value , str ): return Failure ( TypeMismatch ()) return Success ( value ) dictionary = { \"key1\" : \"value\" , \"key2\" : 2 } for key in [ \"key1\" , \"key2\" , \"key3\" ]: result = string_from_key ( dictionary = dictionary , key = key ) match result : case Success ( _ ): print ( f \"Success\" ) case Failure ( NoSuchKey ()): print ( \"Failure with NoSuchKey\" ) case Failure ( TypeMismatch ()): print ( \"Failure with TypeMismatch\" ) case _ : print ( \"default\" ) Warning If are using Result(success=\"my_success\") and Result(failure=NoSuchKey()) syntax intead of recommended one with Success and Failure aliases, you have to use a different match pattern. You would have to use something like: match result : case Result ( str (), _ ): print ( f \"Success\" ) case Result ( _ , NoSuchKey ()): print ( \"Failure with NoSuchKey\" ) case Result ( _ , TypeMismatch ()): print ( \"Failure with TypeMismatch\" ) case _ : print ( \"default\" ) Check this closed issue to learn more about the PEP 636 and this usage in the meiga library.","title":"match"},{"location":"usage/result/#deprecated","text":"","title":"Deprecated \u26a0\ufe0f"},{"location":"usage/result/#throw","text":"Throws the encapsulated failure value if this instance inherits from Error or BaseException. Example result = Success ( \"Hi!\" ) result . throw () # \u27a1\ufe0f It won't throw an exception as is a success. So, this will return None result = Failure ( Error ()) result . throw () # \u27a1\ufe0f It will throw an exception using given Error instance","title":"throw"},{"location":"usage/result/#unwrap_or_throw","text":"Returns the encapsulated value if this instance is a success or throws the encapsulated exception if it is failure. Example result = Result ( success = \"Hi!\" ) value = result . unwrap_or_throw () # \u27a1\ufe0f It will return \"Hi!\" result = Failure ( Error ()) value = result . unwrap_or_throw () # \u27a1\ufe0f It will throw an exception using given Error instance","title":"unwrap_or_throw"}]}